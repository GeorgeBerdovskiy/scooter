
## Names
A name can refer to either a local variable the programmer defined, or a temporary variable generated by the compiler. In the case of variables defined by the programmer, they are mapped from the compiler's representation (an ID) to the string representation for efficiency.

For example, if the user's code contains the following lines ...

```
let apple = 6;
let banana = 5 + apple + 7;
```

... the mapping might look like this...

```
 apple => a
banana => b
```

... and the generated IR might look like this.

```
a = 6;      # The name "a" refers to the variable "apple"
t0 = a + 7; # The name "t0" refers to a temporary compiler generated variable
b = 5 + t0; # The name "b" refers to the variable "banana"
```

#### Representation
In Rust, names are basically wrappers around numbers and the mapping is implemented with a hash table from `&str`s to `Name`s.

```rs
/// Represents a name.
pub struct Name(usize);
```

## Types of Instructions
### Assignments
You can assign binary expressions with either one or two operands to a destination where `<operand>` is either a literal (`<lit>`) or a name (`<name>`).

```
<destination> = [<operand>] <operator> <operand>
```

#### Example

```
a = 5;
t0 = a + 5;
b = - t0;
```

#### Representation
In Rust, this is represented as the `Assignment` struct.

```rs
pub struct Assignment {
    /// The destination.
    pub dest: Name,

    /// The (optional) left operand.
    pub lo: Option<Operand>,

    /// The operator.
    pub op: Operator

    /// The right operand.
    pub ro: Operand
}
```